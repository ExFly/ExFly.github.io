<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Exfly Blog</title>
    <link>https://exfly.github.io/</link>
    <description>Recent content on Exfly Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 16 Sep 2017 15:41:18 +0800</lastBuildDate>
    
	<atom:link href="https://exfly.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>友链</title>
      <link>https://exfly.github.io/links/</link>
      <pubDate>Sat, 16 Sep 2017 15:41:18 +0800</pubDate>
      
      <guid>https://exfly.github.io/links/</guid>
      <description></description>
    </item>
    
    <item>
      <title>关于</title>
      <link>https://exfly.github.io/about/</link>
      <pubDate>Sat, 16 Sep 2017 14:38:23 +0800</pubDate>
      
      <guid>https://exfly.github.io/about/</guid>
      <description>ExFly Keep It Simple &amp;amp; Stupid.</description>
    </item>
    
    <item>
      <title>各种排序算法实现方法</title>
      <link>https://exfly.github.io/algorithm/sort/</link>
      <pubDate>Sat, 16 Sep 2017 16:08:44 +0800</pubDate>
      
      <guid>https://exfly.github.io/algorithm/sort/</guid>
      <description>Source  排序算法比较-wiki  冒泡排序 伪代码 function bubble_sort (array, length) { var i, j; for(i from 0 to length-1){ for(j from 0 to length-1-i){ if (array[j] &amp;gt; array[j+1]) swap(array[j], array[j+1]) } } } 函数 冒泡排序 输入 一个数组名称为array 其长度为length i 从 0 到 (length - 1) j 从 0 到 (length - 1 - i) 如果 array[j] &amp;gt; array[j + 1] 交换 array[j] 和 array[j + 1] 的值 如果结束 j循环结束 i循环结束 函数结束  python实现 def bubble(List): for j in range(len(List)-1,0,-1): for i in range(0, j): if List[i] &amp;gt; List[i+1]: List[i], List[i+1] = List[i+1], List[i] return List  插入排序 python实现 def insert_sort(lst): n=len(lst) if n==1: return lst for i in range(1,n): for j in range(i,0,-1): if lst[j] &amp;lt; lst[j-1]: lst[j], lst[j-1] = lst[j-1], lst[j] return lst  快速排序 python实现 def quicksort(a): if len(a) == 1: return a[0] if len(a) &amp;lt; 1: return 0 return quicksort([x for x in a[1:] if x &amp;lt; a[0]]), [a[0]], quicksort([x for x in a[1:] if x &amp;gt; a[0]])  C语言实现 int partition(int arr[], int low, int high){ int key; key = arr[low]; while(low &amp;lt; high){ while(low &amp;lt; high &amp;amp;&amp;amp; arr[high]&amp;gt;= key ) high--; if(low &amp;lt; high) arr[low++] = arr[high]; while( low &amp;lt; high &amp;amp;&amp;amp; arr[low]&amp;lt;=key ) low++; if(low &amp;lt; high) arr[high--] = arr[low]; } arr[low] = key; return low; } void quick_sort(int arr[], int start, int end){ int pos; if (start &amp;lt; end){ pos = partition(arr, start, end); quick_sort(arr,start,pos-1); quick_sort(arr,pos+1,end); } return; }  归并排序 python实现 from collections import deque def merge_sort(lst): if len(lst) &amp;lt;= 1: return lst def merge(left, right): merged,left,right = deque(),deque(left),deque(right) while left and right: merged.</description>
    </item>
    
  </channel>
</rss>